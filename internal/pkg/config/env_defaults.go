// Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
// or more contributor license agreements. Licensed under the Elastic License;
// you may not use this file except in compliance with the Elastic License.

// Code generated by dev-tools/cmd/buildlimits/buildlimits.go - DO NOT EDIT.

package config

import (
	"math"
	"runtime"
	"strings"
	"time"

	"github.com/elastic/elastic-agent/pkg/packer"
	"github.com/elastic/go-ucfg/yaml"
	"github.com/pbnjay/memory"
	"github.com/pkg/errors"
	"github.com/rs/zerolog/log"
)

const (
	defaultCacheNumCounters = 500000           // 10x times expected count
	defaultCacheMaxCost     = 50 * 1024 * 1024 // 50MiB cache size

	defaultMaxConnections = 0 // no limit
	defaultPolicyThrottle = time.Millisecond * 5

	defaultCheckinInterval = time.Millisecond
	defaultCheckinBurst    = 1000
	defaultCheckinMax      = 0
	defaultCheckinMaxBody  = 1024 * 1024
	defaultCheckinWebsocketReadConcurrency = 50
	defaultCheckinWebsocketWriteConcurrency = 50

	defaultArtifactInterval = time.Millisecond * 5
	defaultArtifactBurst    = 25
	defaultArtifactMax      = 50
	defaultArtifactMaxBody  = 0

	defaultEnrollInterval = time.Millisecond * 10
	defaultEnrollBurst    = 100
	defaultEnrollMax      = 50
	defaultEnrollMaxBody  = 1024 * 512

	defaultAckInterval = time.Millisecond * 10
	defaultAckBurst    = 100
	defaultAckMax      = 50
	defaultAckMaxBody  = 1024 * 1024 * 2

	defaultStatusInterval = time.Millisecond * 5
	defaultStatusBurst    = 25
	defaultStatusMax      = 50
	defaultStatusMaxBody  = 0
)

type valueRange struct {
	Min int `config:"min"`
	Max int `config:"max"`
}

type envLimits struct {
	Agents         valueRange           `config:"num_agents"`
	RecommendedRAM int                  `config:"recommended_min_ram"`
	Server         *serverLimitDefaults `config:"server_limits"`
	Cache          *cacheLimits         `config:"cache_limits"`
}

func defaultEnvLimits() *envLimits {
	return &envLimits{
		Agents: valueRange{
			Min: 0,
			Max: int(getMaxInt()),
		},
		Server: defaultserverLimitDefaults(),
		Cache:  defaultCacheLimits(),
	}
}

type cacheLimits struct {
	NumCounters int64 `config:"num_counters"`
	MaxCost     int64 `config:"max_cost"`
}

func defaultCacheLimits() *cacheLimits {
	return &cacheLimits{
		NumCounters: defaultCacheNumCounters,
		MaxCost:     defaultCacheMaxCost,
	}
}

type serverLimitDefaults struct {
	PolicyThrottle time.Duration `config:"policy_throttle"`
	MaxConnections int           `config:"max_connections"`

	CheckinLimit  WebsocketLimit `config:"checkin_limit"`
	ArtifactLimit Limit `config:"artifact_limit"`
	EnrollLimit   Limit `config:"enroll_limit"`
	AckLimit      Limit `config:"ack_limit"`
	StatusLimit   Limit `config:"status_limit"`
}

func defaultserverLimitDefaults() *serverLimitDefaults {
	return &serverLimitDefaults{
		PolicyThrottle: defaultCacheNumCounters,
		MaxConnections: defaultCacheMaxCost,

		CheckinLimit: WebsocketLimit{
			Limit: Limit{
				Interval: defaultCheckinInterval,
				Burst:    defaultCheckinBurst,
				Max:      defaultCheckinMax,
				MaxBody:  defaultCheckinMaxBody,
			},
			ReadConcurrency: defaultCheckinWebsocketReadConcurrency,
			WriteConcurrency: defaultCheckinWebsocketWriteConcurrency,
		},
		ArtifactLimit: Limit{
			Interval: defaultArtifactInterval,
			Burst:    defaultArtifactBurst,
			Max:      defaultArtifactMax,
			MaxBody:  defaultArtifactMaxBody,
		},
		EnrollLimit: Limit{
			Interval: defaultEnrollInterval,
			Burst:    defaultEnrollBurst,
			Max:      defaultEnrollMax,
			MaxBody:  defaultEnrollMaxBody,
		},
		AckLimit: Limit{
			Interval: defaultAckInterval,
			Burst:    defaultAckBurst,
			Max:      defaultAckMax,
			MaxBody:  defaultAckMaxBody,
		},
		StatusLimit: Limit{
			Interval: defaultStatusInterval,
			Burst:    defaultStatusBurst,
			Max:      defaultStatusMax,
			MaxBody:  defaultStatusMaxBody,
		},
	}
}

var defaults []*envLimits

func init() {
	// Packed Files
	// internal/pkg/config/defaults/gt10000_limits.yml
	// internal/pkg/config/defaults/gt12500_limits.yml
	// internal/pkg/config/defaults/gt5000_limits.yml
	// internal/pkg/config/defaults/gt50_limits.yml
	// internal/pkg/config/defaults/gt7500_limits.yml
	// internal/pkg/config/defaults/lte50_limits.yml
	// internal/pkg/config/defaults/max_limits.yml
	unpacked := packer.MustUnpack("eJzsl1+PqkYYxu/7Mfa66QKKjU3OxawIC5vBSIABbhoGFMHhT44gf5p+92ZArausQtrkJE0vTeSZd573N88788dLmOSb74lLXrN98OqlyTYMXv3N1i1IfngNcpZhGOZ3EsZhfviljsnLby84MXOLExMH8YzXpB/y4i130XQmC8sSCqBchCDASJyuQlDByCghyGoHqUeMWIJjjTjiPHcRv/ViMV+FYAr1fb2I1Z3N7YjFVRlG5Kxb+Ijd2tycxYlGvATSNTi6BgRpIEvsbiPOIzxRmVUIaijsJ1A3aiiAD48zaz826xu9EnNVZk/I1pd2NZ5oDJaMmSyYuVde6XF84SCVcdG88Jo0gI1M90W/j1zJjFyOFGfdVZAG8gIELuIZx1I4G5UzWTBK+G421Ad58Rb6ltL4Qhqo57oXN/6s6dpi7UsktpHKXLRDuiYIZIkUvkT3Ix5WIWCh8Ma29S5AYCdm7U3WM1lYn2oE3T6ENFhdfDILL54fsDg/uIjNaC2n2rLOV2eHhTSA+lt+r7u8rbk+ebGzuXyLJZK71nrWp6fqoPQteKpJYb2k7RNzZoRyY1vBTBYCWvu3l5+fwsjxI2CsaQFXMDYdOA9hrNQITlWQRTZSU8c8GfYO2w12a6lHv2t20/0fnOHIbWtHYW2bDSPAq82ShREoF4lKTSEe+aznSfS3ylsTLfXiOeNLFaEG49a0i16BYzPyJXLE7QGA9dlAemBsLs8wuTT2HwEDdaOEwrJtrpdomROLkf8EmpFNptoEJ8oRS9UFHhn0HaJlie91q7uao5MXSP3+Lx3KaVt78G0AkPyIcDSuOKF+eGwbVLEZYY7NHcTvHaRtMSKFNVF2WG/3xqyGs8h8EYzsJRhB1lA/HEs5ea81rVfvb0cskWhjzhn3XTn679rB0a8C4atg1MHIYFT6A+amp2ozOhTrL1i5YVD+wQwO2z/Vg2AYf8Ppu0pCtnUmUYjNzXOMzMKRzL3FsTRJahsxXVXR+sPmRNrZz7RIPItNSpfZdqAl4XkKjhzJRvk4Bb2R5Jk9zhu3J5/6UrWdtBTGRc7OnmhPCBmkeyHRQXyNuerwjGYosfdJpd+m9VDqtME1Pifu1xETuEu4v0/f6Xr4kLt1udLtwdy1V5w+7nTArARjoo6fvuxj7uRy5PStehKkvk+m1puR7Ik9fZXv0/QHXwMhume5S7hPeswQ/ki+GRJ5naXGE9TAuHh78OIYe8GDwvPBOuqC1xMXMDL642IwXsuyV/c+hkYN1N5oW99EUeu1GLns46PVv++7Yfp0kMZuNTTT4IAMg7Xa2NPhT9ruRv8fedK2r67/n7SnJ+2fP/0VAAD//1871n0=")

	for f, v := range unpacked {
		cfg, err := yaml.NewConfig(v, DefaultOptions...)
		if err != nil {
			panic(errors.Wrap(err, "Cannot read spec from "+f))
		}

		l := defaultEnvLimits()
		if err := cfg.Unpack(&l, DefaultOptions...); err != nil {
			panic(errors.Wrap(err, "Cannot unpack spec from "+f))
		}

		defaults = append(defaults, l)
	}
}

func loadLimits(agentLimit int) *envLimits {
	return loadLimitsForAgents(agentLimit)
}

func loadLimitsForAgents(agentLimit int) *envLimits {
	for _, l := range defaults {
		// get nearest limits for configured agent numbers
		if l.Agents.Min < agentLimit && agentLimit <= l.Agents.Max {
			log.Info().Msgf("Using system limits for %d to %d agents for a configured value of %d agents", l.Agents.Min, l.Agents.Max, agentLimit)
			ramSize := int(memory.TotalMemory() / 1024 / 1024)
			if ramSize < l.RecommendedRAM {
				log.Warn().Msgf("Detected %d MB of system RAM, which is lower than the recommended amount (%d MB) for the configured agent limit", ramSize, l.RecommendedRAM)
			}
			return l
		}
	}
	log.Info().Msgf("No applicable limit for %d agents, using default.", agentLimit)
	return defaultEnvLimits()
}

func getMaxInt() int64 {
	if strings.HasSuffix(runtime.GOARCH, "64") {
		return math.MaxInt64
	}
	return math.MaxInt32
}
